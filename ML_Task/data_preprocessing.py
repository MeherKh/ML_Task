# AUTOGENERATED! DO NOT EDIT! File to edit: ../01_data_preprocessing.ipynb.

# %% auto 0
__all__ = ['load_data', 'TransformCampaign']

# %% ../01_data_preprocessing.ipynb 2
import pandas as pd
import numpy as np
import holidays
import math
import matplotlib.pyplot as plt
import seaborn as sns
import torch
import warnings
warnings.filterwarnings('ignore')
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from datetime import datetime, timedelta
from pathlib import Path
from sklearn.preprocessing import OneHotEncoder
from sklearn.base import BaseEstimator, TransformerMixin
from datetime import datetime
from nbdev.showdoc import *

# %% ../01_data_preprocessing.ipynb 5
def load_data(path):
    """Load a dataframe."""
    if isinstance(path, (str, Path)):
        df = pd.read_csv(path)
        if df.empty:
            raise ValueError("DataFrame Is empty")
    else:
        raise ValueError("Check your data path")
    return df

# %% ../01_data_preprocessing.ipynb 13
class TransformCampaign(BaseEstimator, TransformerMixin):
    def __init__(self):
        """Constructor"""
        self.ohe = OneHotEncoder()
        self.categorical_cols = ["Sector", "Objetive", "Season"]

    def fit(self, X: pd.DataFrame, y=None):
        """fit function to prepare data"""
        X_ = X.copy()
        return self

    def number_of_weekends(self, startDate: datetime, endDate: datetime) -> int:
        """determine how many weekends there are in a particular timeframe."""
        duration = (endDate - startDate).days + 1
        date_list = [startDate + timedelta(days=x) for x in range(duration)]
        week_end_days = 0
        for date in date_list:
            if date.weekday() > 4:
                week_end_days = week_end_days + 1
        return week_end_days

    def is_holiday(self, starDate: datetime, endDate: datetime, endDateYear: int):
        """check whether there are any holidays at a specific time period."""
        holi_days = []
        for date, name in sorted(holidays.TN(years=endDateYear).items()):
            holi_days.append({"date": date, "holiday": name})
        holi_days = pd.DataFrame(holi_days)
        holi_days["date"] = pd.to_datetime(holi_days["date"])
        number_of_holidays = 0
        for _, row in holi_days.iterrows():
            date = row["date"]
            if starDate <= date <= endDate:
                number_of_holidays = number_of_holidays + 1
        return int(number_of_holidays > 0)

    def season_of_date(self, date):
        """determine the season of a given date"""
        year = str(date.year)
        seasons = {
            "spring": pd.date_range(start="21-03-" + year, end="20-06-" + year),
            "summer": pd.date_range(start="21-06-" + year, end="22-09-" + year),
            "autumn": pd.date_range(start="23-09-" + year, end="20-12-" + year),
        }
        if date in seasons["spring"]:
            return "spring"
        if date in seasons["summer"]:
            return "summer"
        if date in seasons["autumn"]:
            return "autumn"
        else:
            return "winter"

    def transform(self, X: pd.DataFrame, y=None, data_type="train"):
        """transform data and create new features"""
        X_ = X.copy()
        # 1. Extract new features from dates
        # convert startDate and EndDate to a date format
        X_.StartDate = pd.to_datetime(X_.StartDate)
        X_.EndDate = pd.to_datetime(X_.EndDate)
        # extract year from dates
        X_["StartDateYear"] = X_.StartDate.apply(lambda d: d.year)
        X_["EndDateYear"] = X_.EndDate.apply(lambda d: d.year)
        # extract duration
        X_["duration"] = (X_["EndDate"] - X_["StartDate"]).dt.days
        # extract if thr's a holiday
        X_["Holidays"] = X_.apply(
            lambda campaign: self.is_holiday(
                campaign["StartDate"], campaign["EndDate"], campaign["EndDateYear"]
            ),
            axis=1,
        )
        # number of weekends
        X_["NumberOfWeekends"] = X_.apply(
            lambda campaign: self.number_of_weekends(
                campaign["StartDate"], campaign["EndDate"]
            ),
            axis=1,
        )
        # Season
        X_["Season"] = X_.apply(
            lambda campaign: self.season_of_date(campaign["StartDate"])
            + "-"
            + self.season_of_date(campaign["EndDate"]),
            axis=1,
        )
        # delete title, date columns
        X_.drop(
            ["CampaignTitle", "StartDate", "EndDate", "StartDateYear", "EndDateYear"],
            axis=1,
            inplace=True,
            errors="ignore",
        )
        # 2. encode categorical variables
        if data_type == "train":
            self.ohe.fit(X_.loc[:, self.categorical_cols])
        catego_sparse = self.ohe.transform(X_.loc[:, self.categorical_cols])
        catego_encoded = catego_sparse.toarray()
        features = self.ohe.get_feature_names_out(self.categorical_cols)
        df_catego_encoded = pd.DataFrame(
            catego_encoded, index=X_.index, columns=features
        )
        X_ = pd.concat([X_, df_catego_encoded], axis=1)
        X_.drop(self.categorical_cols, axis=1, inplace=True, errors="ignore")
        # 3. transform target values to double by applying log function
        if "Results" in X_.columns:
            # eliminate outliers
            # max and min threshold for results
            max_th_r = X_["Results"].quantile(0.95)
            min_th_r = X_["Results"].quantile(0.05)
            X_ = X_[(X_.Results < max_th_r) & (X_.Results > min_th_r)]
            # max and min threshold for Coverage
            max_th_c = X_["Coverage"].quantile(0.95)
            min_th_c = X_["Coverage"].quantile(0.05)
            X_ = X_[(X_.Coverage < max_th_c) & (X_.Coverage > min_th_c)]
            # max and min threshold for Impressions
            max_th_i = X_["Impressions"].quantile(0.95)
            min_th_i = X_["Impressions"].quantile(0.05)
            X_ = X_[(X_.Impressions < max_th_i) & (X_.Impressions > min_th_i)]
            # divide by Usd spent
            X_["Results"] = X_["Results"] / X_["USD spent"]
            X_["Coverage"] = X_["Coverage"] / X_["USD spent"]
            X_["Impressions"] = X_["Impressions"] / X_["USD spent"]
            # apply log
            X_["Results"] = X_["Results"].apply(lambda r: 0 if r <= 0 else np.log2(r))
            X_["Coverage"] = X_["Coverage"].apply(lambda c: 0 if c <= 0 else np.log2(c))
            X_["Impressions"] = X_["Impressions"].apply(
                lambda i: 0 if i <= 0 else np.log2(i)
            )

        return X_
