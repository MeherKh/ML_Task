# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_data_modeling.ipynb.

# %% auto 0
__all__ = ['DataModeling']

# %% ../02_data_modeling.ipynb 2
import pandas as pd
import torch
from torch.utils.data import Dataset
from fastai.tabular.all import *
from .data_preprocessing import *
from nbdev.showdoc import *

# %% ../02_data_modeling.ipynb 7
class DataModeling:
    def __init__(self):
        # data transformer
        self.transformer = TransformCampaign()
        # device
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        # train data
        self.data = None

    def data_loaders(self, train_data, n_split):
        """
          setting up dataloaders to split data into validation and train

        Parameters
        ----------
        train_data: pd.DataFrame
            train data
        n_splits: int
            validation set ratio

        Returns
        -------
        dls, X: list

        """
        X_ = train_data.copy()
        # clean and transform data
        X_ = self.transformer.fit_transform(X_)
        # splits data between train/validation (n_split for validation) randomly.
        splits = RandomSplitter(n_split, seed=42)(X_)
        # indep variables
        cont_names = [
            var
            for var in X_.columns
            if var not in ["CampaignTitle", "Results", "Coverage", "Impressions"]
        ]
        # create a dataloader using fastai tabularPandas
        # we specify data, splits(train and validation data),
        # continuous columns
        # target values (here we have 3 outputs: Results,Coverage,Impressions)
        # y_block : the task which we want to perform , here we want regression
        # we can also use gpu if it exists
        dls = TabularPandas(
            X_,
            splits=splits,
            procs=[Normalize],
            cont_names=cont_names,
            y_names=["Results", "Coverage", "Impressions"],
            y_block=RegressionBlock(3),
            device=self.device,
        ).dataloaders(patch=".")
        return dls, X_

    @staticmethod
    def find_best_lr(learner, algos):
        """
          find the best learning rate

        Parameters
        ----------
        learner: fastai.tabular.learner.TabularLearner
            fastai learner model
        algos: list
            optimization algorithms to find the best learning rate

        Returns
        -------
        lr: float

        """
        # find the best learning rate by specifing some optimization algorithms
        lr = learner.lr_find(suggest_funcs=algos)
        return lr

    def train(
        self, train_data, layers, n_epochs, n_splits, lr_algos, metrics, n_outputs
    ):
        """
          training phase to fit the model

        Parameters
        ----------
        train_data: pd.DataFrame
            train data
        layers: list
            model layers
        n_epochs: int
            the number of complete passes through the training dataset.
        n_splits: int
            validation set ratio
        lr_algos: list
            optimization algorithms to find the best learning rate
        metrics: list
            a list of metrics to assess the model
        n_outputs: int
            the number of model outputs

        Returns
        -------
        learner: fastai.tabular.learner.TabularLearner

        """
        X_ = train_data.copy()
        # get dataloaders
        dls, X_ = self.data_loaders(X_, n_splits)
        self.data = X_
        # specify outputs range
        # min range
        mins = [
            X_.Results.min(),
            X_.Coverage.min(),
            X_.Impressions.min(),
        ]
        # max range
        maxs = [
            X_.Results.max(),
            X_.Coverage.max(),
            X_.Impressions.max(),
        ]
        # outputs range
        y_range = (
            torch.tensor(mins).to(self.device),
            torch.tensor(maxs).to(self.device),
        )
        # setting up a fastai learner which will implement a Neural Network
        # with 2 layer and 10 neurons in each one.
        # 3 outputs (target values)
        # using 4 metrics to assess the model
        learner = tabular_learner(
            dls,  # dataloaders
            metrics=metrics,  # metrics
            layers=layers,
            n_out=n_outputs,
            y_range=y_range,
        )
        # find the best learning rate
        lr = DataModeling.find_best_lr(learner, lr_algos)
        # to find the best learning rate, we usually pick a value between valley and slide values
        lr = (lr.valley + lr.slide) / 2
        # fit data
        learner.fit(n_epochs, lr=lr, cbs=[ShowGraphCallback()])

        return learner

    def test(self, test_data, learner):
        """
          predict outputs using unseen data

        Parameters
        ----------
        test_data: pd.DataFrame
            test data
        learner: fastai.tabular.learner.TabularLearner
            model

        Returns
        -------
        output: pd.DataFrame

        """
        X_ = test_data.copy()
        # transform test data
        X_ = self.transformer.transform(X_, data_type="test")
        # test dataloader
        test_dl = learner.dls.test_dl(X_)
        # predict outputs
        preds, _ = learner.get_preds(dl=test_dl)
        preds = pd.DataFrame(
            preds, index=X_.index, columns=["results", "coverage", "impressions"]
        )
        # output
        output = pd.concat([test_data, preds], axis=1)
        # Target values rescalling
        # results
        output["results"] = np.exp2(output.results) * output["USD spent"]
        # coverage
        output["coverage"] = np.exp2(output.coverage) * output["USD spent"]
        # impressions
        output["impressions"] = np.exp2(output.impressions) * output["USD spent"]

        return output

    @staticmethod
    def evaluate(train_output, test_output):
        """
          evaluate test outputs

        Parameters
        ----------
        train_data: pd.DataFrame
            train data
        test_data: pd.DataFrame
            test data

        Returns
        -------
        train_agg, test_agg: pd.DataFrame, pd.DataFrame

        """
        # aggregate train data by sector
        train_agg = train_output.groupby(["Sector"]).agg(
            {"Results": "mean", "Coverage": "mean", "Impressions": "mean"}
        )
        # aggregate test data by sector
        test_agg = preds.groupby(["Sector"]).agg(
            {"results": "mean", "coverage": "mean", "impressions": "mean"}
        )
        # return
        return train_agg, test_agg

    @staticmethod
    def export(learner, model_class, path_class, path_model):
        """
          save models

        Parameters
        ----------
        learner: fastai.tabular.learner.TabularLearner
            fitted model
        model_class: __main__.DataModeling
            model class instance
        path_class: str
            class path
        path_model: str
            model path

        Returns
        -------
        None

        """
        # save model
        learner.export(path_model)
        # save class instance
        torch.save(model_class, path_class)
